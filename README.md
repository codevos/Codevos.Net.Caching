# Codevos.Net.Caching

Provides a universal way to cache method return values.

## Attribute based caching

### Step 1 - Define which method return values should be cacheable

#### Interface method caching

Mark the interface with the __Cache__ attribute.
This enables caching for each method in the interface.

```csharp
    [Cache]
    public interface IMyService
    {        
        Task<IEnumerable<MyModel>> GetAll(CancellationToken cancellationToken);
    }
```

Or mark the methods of your interface with the __Cache__ attribute.

```csharp
    public interface IMyService
    {
        [Cache]
        Task<IEnumerable<MyModel>> GetAll(CancellationToken cancellationToken);
    }
```

#### Class method caching

Mark the class with the __Cache__ attribute.
This enables caching for each __virtual__ method in the class.

```csharp
    [Cache]
    public class MyOtherService
    {
        public virtual async Task<IEnumerable<MyModel>> GetAll(CancellationToken cancellationToken)
        {
            // implementation
        }
    }
```

Or declare the methods of your class as __virtual__ and mark them with the __Cache__ attribute.

```csharp
    public class MyOtherService
    {
        [Cache]
        public virtual async Task<IEnumerable<MyModel>> GetAll(CancellationToken cancellationToken)
        {
            // implementation
        }
    }
```

#### Cache duration

You can specify the cache duration and make the expiration absolute or sliding.

```csharp
[Cache(ExpirationHours = 1, SlidingExpiration = true)]
Task<IEnumerable<MyModel>> GetAll(CancellationToken cancellationToken);
```

### Step 2 - Add method result caching to the service collection

__AddMethodResultCaching()__ should be called __after__ registering all cacheable services.

```csharp
private void ConfigureServices(IServiceCollection services)
{
    services
        .AddSingleton<IMyService, MyService>()
        .AddSingleton<MyOtherService>()
        .AddMethodResultCaching();
}
```

## Fluent API for enabling cache on interfaces / classes without using attributes

An alternative to using cache attributes is to use the fluent API on the IServiceCollection.

```csharp
private void ConfigureServices(IServiceCollection services)
{
    services
        .AddSingleton<IMyService, MyService>()
        .AddMethodResultCaching(
            configure =>
            {
                configure
                    // enable cache for each method of IMyService
                    .AddCache<IMyService>(cache =>
                    {
                        cache.ExpirationHours = 1
                    })
                    // enable specific cache for method 'MyMethod' of IMyService
                    .AddCache<IMyService>(x => nameof(x.MyMethod), cache =>
                    {
                        cache.ExpirationMinutes = 30
                    });
            }
        );
}
```

## Complex parameter type serialization for generated cache key

The cache keys are generated by using JSON serialization.
If the method being cached has complex arguments it is possible to specify how this argument should be serialized.

```csharp
private void ConfigureServices(IServiceCollection services)
{
    services
        .AddSingleton<IMyService, MyService>()
        .AddMethodResultCaching(
            configure =>
            {
                configure
                    .SetCacheKeyArgumentResolver((type, obj) => 
                    {
                        if (type == typeof(MyComplexType)) return ((MyComplexType)obj).Value;
                        return obj;
                    });
            }
        );
}
```

## Using unique cache keys per environment

It is possible to include an extra segment in the generated cache key to ensure that keys are different on each environment.  
Use cases are diffent hosting environments (test/qa/prod) and different data sources.

```csharp
private void ConfigureServices(IServiceCollection services)
{
    services
        .AddSingleton<IMyService, MyService>()
        .AddMethodResultCaching(
            cacheKeySuffixFactory: serviceProvider => 
            {
                var hostEnvironment = serviceProvider.GetRequiredService<IHostEnvironment>();
                return hostEnvironment.EnvironmentName;
            }
        );
}
```

## Dedicated cache

The registered __IDistributedCache__ is used by default for reading/writing cache entries.  
There are many [distributed cache implementations](https://docs.microsoft.com/en-us/aspnet/core/performance/caching/distributed) available.
If no __IDistributedCache__ is registered, a __MemoryDistributedCache__ instance will be created.  
It is however possible to create a dedicated cache instance, which is separated from the regular __IDistributedCache__.

```csharp
services
    .AddMethodResultCaching(registerDedicatedDistributedCache: services => services.AddDistributedMemoryCache());
```

## Invalidating the cache

Cache entries can be invalidated by using the __CacheInvalidator__ class.
The __CacheInvalidator__ is made available through dependency injection.

```csharp
private readonly CacheInvalidator CacheInvalidator;

public class Invalidator(
    CacheInvalidator cacheInvalidator
)
{
    CacheInvalidator = cacheInvalidator;
}
```

### Invalidating all cache entries for a particular service.

```csharp
CacheInvalidator.Invalidate<IMyService>();
```

### Invalidating cache entries for a specific method of a service.

```csharp
CacheInvalidator.Invalidate<IMyService>(x => nameof(x.GetAll));
```